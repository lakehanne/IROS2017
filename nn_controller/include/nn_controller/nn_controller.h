/*
Base class for a controller. Controllers take in sensor readings and choose the action.
*/
#pragma once

// Headers.
#include <queue>
#include <cmath>
#include <mutex>
#include <thread>
#include <time.h>
#include <chrono>
#include <vector>
//ros used
#include <ros/ros.h>
#include <std_msgs/Float64.h>
#include <geometry_msgs/Point.h>
#include <geometry_msgs/Pose.h>
//boost unused
#include <boost/scoped_ptr.hpp>
//controller factory headers
#include <ensenso/ValveControl.h>
#include <ensenso/boost_sender.h>
#include "nn_controller/amfcError.h"
#include "nn_controller/controller.h"
#include "nn_controller/predictor_params.h"
/* ______________________________________________________________________
    *
    *   This code is part of the superchick project. 
    *  
    *
    *   Author: Olalekan Ogunmolu
    *   Date: Nov. 3, 2016
    *   Lab Affiliation: Gans' Lab, Dallas, TX
    *__________________________________________________________________________
*/

#include <ros/time.h>
#include <ros/ros.h>
#include <Eigen/Dense>
    #include <stdlib.h> /*system, NULL, ..*/

#include "nn_controller/amfc.h"
#include "nn_controller/options.h"
#include "nn_controller/predictor.h"
#define BOOST_NO_CXX11_SCOPED_ENUMS     
#include <boost/filesystem.hpp>
#undef BOOST_NO_CXX11_SCOPED_ENUMS
#include <boost/tuple/tuple.hpp>
#include <boost/property_tree/json_parser.hpp>

#define OUT(__o__) std::cout<< __o__ << std::endl;

namespace amfc_control
{
    /**   @brief
    *  enum for bladder types
    *
    */
    enum class DOF_MOTION_ENUM: std::uint16_t {
        ROLL_POS=0,
        ROLL_NEG=1,
        PITCH_POS=2,
        PITCH_NEG=3,
        Z_POS=4,
        Z_NEG=5,
    };

    /*
    * The neural network accounts for the parametric uncertainties and we do not needd
    * a baseline controller for now
    */
    class Controller
    {
    private:
        /* @brief
        *
        * compute control law with robust adaptive estimated net params 
        *
        */        
        bool with_net_;

        /** @brief
        *
        * name used in saving ref and actual to disk
        *
        */        
        std::string filename_;

        DOF_MOTION_ENUM dof_motion_type_;
        /* @brief
        *
        *   paths used to store ref and saved paths
        */
        boost::filesystem::path nn_controller_path_;
        std::stringstream ss;

        /* @brief
        *
        *  sigma modification to ensure lyapunov function stays negative along 
        *  the trajectories of the error dynamics of the system
        *  useSigma adapts the control law based on given leakage terms
        * 
        *   sigma_y and sigma_r are the sigma modification terms  
        */
        bool useSigma;
        double sigma_y, sigma_r;

        /* @brief
        *
        *   error state space between the reference model signal 
        *   and the actual head pose
        *
        */
        Eigen::VectorXd tracking_error;

        /* @brief
        *
        *   ROS node handler used in initializing ros protocols across the distributed
        *   system
        */
        ros::NodeHandle n_;

        /* @brief
        *
        *  publishers used in communicating pose, and control law to 
        *  torch's neural network approximator
        */
        ros::Publisher control_pub_;

        /* @brief
        *
        * k is a steady constant used in penalizing the high gains that the controller generates
        * this is necessary in order for the Dakota valves to be able to accommodate 
        * the ranges of control law generated by the control scheme
        */
        double k;

        /* @brief
        *
        *  m is the number of controls// 6 in our experiments
        *  n is the states of the system// 3 in our experiment
        */
        int m, n;

        /*@brief
        *
        * counter is used in the time constant for integrating the 
        * adaptation rates
        */
        unsigned counter;

        /* @brief P is symmetric positive definite matrix obtained from the lyapunov functiuon Q
        *
        *  B is the [3x6] matrix that maps the controls into the state space
        *
        *  Am is [3x3]: the state-mapping matrix of the reference model
        *
        *  Bm is [3x3]: the input-mapping matrix of the reference model
        *
        * B is [3 x 6]
        */
        Eigen::Matrix3d P, Am, Bm; 
        Eigen::MatrixXd B;
        /*@brief
        *
        * Gamma_y and Gamma_r are matrices of adaptation gains 
        *  to tune the controller. Both are [3x3]
        */
        Eigen::MatrixXd Gamma_y, Gamma_r;

        /* @brief
        *
        * ref_ is the command signal given to the patient from 
        * the command line
        */
        Eigen::Vector3d ref_;

        /* @brief
        *
        *   Ky_hat_dot is the pure integrator state adaptation gain 
        *   that ensures the derivative of the Lyapunov function goes to zero.
        *
        *   Kr_hat_dot is the pure integrator reference adaptation gain 
        *   that ensures the derivative of the Lyapunov function goes to zero.
        */
        Eigen::MatrixXd Ky_hat_dot, Kr_hat_dot; 

        /* @brief
        *
        *  Ky_hat is the integrated result of the time derivative of Ky_hat
        *  Kr_hat is the integrated result of the time derivative of Kr_hat
        */
        Eigen::MatrixXd Ky_hat, Kr_hat;

        /* @brief
        *
        *   pose_info is the returned measurement from the sensor
        */
        Eigen::VectorXd pose_info;

        /* @brief
        *
        *   reference model output, ref_model differential and final value of ref
        *    model integral
        */
        Eigen::Vector3d ym, ym_dot, ym_int; 

        //reference model  and integration term
        Eigen::MatrixXd expAmk, expAmk_tau;              

        /*@brief
        *
        * Lambda is an unknown pos def symmetric matrix in R^{m x m}
        * matrix of
        *
        * We are interested in the sign of Lambda 
        */
        Eigen::MatrixXd Lambda, sgnLambda;

        /* brief
        *
        * this is the control law sent to the valves 
        *
        */
        Eigen::VectorXd u_control;

        /* @brief
        *
        *   vector used to penalize network predictions
        */
        Eigen::VectorXd alpha;

        /* @brief
        *
        *   convenience data structures for creating delayed data
        */
        std::queue<Eigen::VectorXd> pose_queue, tracking_error_queue,
                                    Ky_hat_queue, ref_queue, Kr_hat_queue;
        
        /* @brief
        *
        * LSTM approximator ROS service predictor
        *
        */
        nn_controller::predictor pred_;
        
        /* @brief
        *
        *   neural net  weights
        */
        Eigen::Matrix<double, 6, 6> modelWeights;
        
        /* @brief
        *
        *   neural net  biases
        */
        Eigen::VectorXd modelBiases;
        
        /* @brief
        *
        * boost asio api for streaming pose, ref and valve controllers
        *  to the RIO
        */
        boost::asio::io_service io_service;
        
        /* @brief
        *
        *  address to stream the pose info to
        *  any one on the local LAN or WAN should be able to receive the message
        */
        const std::string multicast_address;
        
        /* @brief
        * 
        *   loss from the neural network approximator
        */
        double loss;

        /* @brief
        *
        * LSTM approximator Eigen predictor
        *
        */
        Eigen::VectorXd pred;

        /* @brief
        *
        * mutexes used to avoid data races in different subroutines of program
        *
        */
        std::mutex net_loss_mutex, pred_mutex,
                    mutex, pose_mutex, weights_mutex, biases_mutex;
        
        /* @brief
        *
        *  boolean operators used to receive updated messages from shared mutexes
        *
        */                    
        bool updatePoseInfo, print, updateController, updateWeights, 
             updateBiases, resetController, updateNetLoss, updatePred,
             save;

        /* @brief 
        *   
        *   Aliases used in boost ode integrator api
        *   The type of container used to hold the state vector 
        *
        */
        using state = Eigen::Matrix<double, 3, 6>;
        using ym_state = Eigen::Vector3d;

        /* @brief
        *
        *  Control torques sent to valves
        *
        */
        ensenso::ValveControl u_valves_;

        /* @brief
        *  control law retrieved from the neural network
        *
        */
        Eigen::VectorXd net_control;

        /* @brief
        *
        * At the first iteration, due to the non-availability of the 
        * network prediction, we guess the control scheme to use 
        * since the predictor takes delayed control signals and pose messages
        * as input
        */
        Eigen::VectorXd guessControl;

        /* @brief
        * computed pose that we send to rio
        */
        geometry_msgs::Pose pose_;

        /* @brief
        * std::vector that stores previous values of ym
        */
        std::vector<Eigen::Vector3d> prev_ym;

        // std::vector<Eigen::VectorXd> prev_Ky_hat, prev_Kr_hat;

        /* @brief
        *
        * implements the signum of the Lambda matrix
        */
        template <typename T> 
        int sgn(T val)         {
            return (T(0) >  val) - (val > T(0));
        }

        /* @brief
        *
        *   Convenience function used to initialize static state and 
        *   reference model matrices
        */
        void initMatrices()        {   
            n = 3; m = 6; 
            Am.setIdentity(n, n);   // Hurwitz matrix
            Bm.setIdentity(n, n);       //note from B*Lambda*Kr^T eq.10
            B.setZero(n, m);        //R^{3 x 6}
            Gamma_y.setIdentity(n, n); //will be 3 X 3 matrix
            Gamma_r.setIdentity(n, n); //will be 3 X 3 matrix
            //Lambda models controlundertainties by an R^{nxn} diagonal matrix
            //with positive elements
            Lambda.setIdentity(m, m); 
            //initialize sgnLambda to zeros
            sgnLambda.setIdentity(m,m);
            //find the sign of the Lambda matrix
            Lambda *= 1;  
            OUT("Lambda: " << Lambda);
            //generate the signum of the Lambda matrix in O(12) time
            for(int i = 0; i < Lambda.rows(); ++i)  {
                for(int j = 0; j < Lambda.cols(); ++j)    {
                    sgnLambda(i, j) = sgn(Lambda(i, j));
                }
            }       

            OUT("sgnLambda: " << sgnLambda);

            P.setIdentity(n, n); // R ^{n x n}  // from lyapunov equation
            expAmk.setIdentity(n, n);  // from ym = (expAm*k ) * Bm r
            expAmk_tau.setIdentity(n,n);

            modelBiases.resize(6);

            P *= -1705./2668*1000; //-11503./180; //
            Am *= -1334./1705;
            // set Bm to -Am in order to enforce unity dc fain from r to ym
            Bm = -Am;

            //initialize B so that we have the difference between voltages to each IAB
            B(0,0) = 1; B(0, 1) = -1;
            B(1,2) = 1; B(1, 3) = -1;
            B(2,4) = 1; B(2, 5) = -1;

            pose_info.resize(3);

            //gamma scaling factor for adaptive gains
            k =  1e-1; //1e-12/8;

            Gamma_y *= k;// * Gamma_y.diagonal();
            Gamma_r *= k;// * Gamma_r.diagonal();

            // initialize Kr_hat and Ky_hat to dummy values for sigma modification
            Kr_hat.setZero(n,m);
            Ky_hat.setZero(n,m);
        }

    public:
        // Constructor.
        Controller(ros::NodeHandle nc, 
                    const Eigen::Vector3d& ref, bool print, bool useSigma, 
                    bool save);
        Controller();
        // Destructor.
        virtual ~Controller();
        //pose callback
        void getRefTraj();

        /*compute control law
        * Ky_hat_dot will be 6x3, 
        * pose_info will be 3x1
        * Kr_hat_dot will be 6x3
        * ref_ will be 3x1
        * modelWights is \theta & will be 3x3
        * phi(x) will be lagged params 3x1
        * u_control will be 6x1
        */
        void ControllerParams(Eigen::VectorXd&& pose_info);
        // subscribe to neural net component of control law
        void net_control_subscriber(const ensenso::ValveControl& net_control_law);
        //transform eigenPose to ensenso::HeadPose format
        void vectorToHeadPose(Eigen::VectorXd&& pose_info, 
                                          geometry_msgs::Pose& eig2Pose);
        //predictor from real-time predictor.lua 
        //loss from real-time predictor.lua 
        // void loss_subscriber(const std_msgs::Float64& net_loss);
        // void pred_subscriber(const geometry_msgs::Pose& pred);
        // //controller service ::DEPRECATED
        // virtual bool configure_controller(
        //     nn_controller::controller::Request  &req,
        //     nn_controller::controller::Response  &res);
        //predictor params for pretrained model
        // virtual bool configure_predictor_params(
        //         nn_controller::predictor_params::Request  &req,
        //         nn_controller::predictor_params::Response  &res);
        void getPoseInfo(const geometry_msgs::Pose& headPose, Eigen::VectorXd pose_info);
        ros::Time getTime();      
        virtual void pose_subscriber(const geometry_msgs::Pose& headPose);
    };
}
